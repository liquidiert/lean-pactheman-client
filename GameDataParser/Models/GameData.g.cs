//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.1.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::System;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
using global::Bebop.Exceptions;
//
// This source code was auto-generated by bebopc, Version=2.1.0.
//
namespace GameDataParser {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseGameData : System.IEquatable<BaseGameData> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseLevelData[] LevelData { get; set; }

    public bool Equals(BaseGameData other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (LevelData is null ? other.LevelData is null : other.LevelData is not null && LevelData.SequenceEqual(other.LevelData));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGameData baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= LevelData.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGameData left, BaseGameData right) => Equals(left, right);
    public static bool operator !=(BaseGameData left, BaseGameData  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class GameData : BaseGameData {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGameData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGameData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGameData record, ref BebopWriter writer) {
      {
        var length0 = unchecked((uint)record.LevelData.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          GameDataParser.LevelData.EncodeInto(record.LevelData[i0], ref writer);
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGameData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GameData Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGameData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GameData Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGameData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GameData Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGameData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GameData Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGameData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GameData Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GameData DecodeFrom(ref BebopReader reader) {

      BaseLevelData[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BaseLevelData[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BaseLevelData x0;
          x0 = GameDataParser.LevelData.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      return new GameData {
        LevelData = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGameData, new() {
      BaseLevelData[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BaseLevelData[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BaseLevelData x0;
          x0 = GameDataParser.LevelData.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      return new T {
        LevelData = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseGhostMoveMsg : System.IEquatable<BaseGhostMoveMsg> {
    public const uint OpCode = 0x6;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostPositions { get; set; }

    public bool Equals(BaseGhostMoveMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostPositions is null ? other.GhostPositions is null : other.GhostPositions is not null && GhostPositions.SequenceEqual(other.GhostPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostMoveMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= GhostPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostMoveMsg left, BaseGhostMoveMsg right) => Equals(left, right);
    public static bool operator !=(BaseGhostMoveMsg left, BaseGhostMoveMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class GhostMoveMsg : BaseGhostMoveMsg {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostMoveMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostMoveMsg record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.GhostPositions.Count));
      foreach (var kv0 in record.GhostPositions) {
        writer.WriteString(kv0.Key);
        GameDataParser.Position.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostMoveMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMoveMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostMoveMsg DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = GameDataParser.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new GhostMoveMsg {
        GhostPositions = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostMoveMsg, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = GameDataParser.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new T {
        GhostPositions = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseLevelData : System.IEquatable<BaseLevelData> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseTimeStepData[] TimeSteps { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Winner { get; set; }

    public bool Equals(BaseLevelData other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (TimeSteps is null ? other.TimeSteps is null : other.TimeSteps is not null && TimeSteps.SequenceEqual(other.TimeSteps)) && Winner == other.Winner;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseLevelData baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= TimeSteps.GetHashCode();
      hash ^= Winner.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseLevelData left, BaseLevelData right) => Equals(left, right);
    public static bool operator !=(BaseLevelData left, BaseLevelData  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class LevelData : BaseLevelData {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseLevelData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseLevelData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseLevelData record, ref BebopWriter writer) {
      {
        var length0 = unchecked((uint)record.TimeSteps.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          GameDataParser.TimeStepData.EncodeInto(record.TimeSteps[i0], ref writer);
        }
      }
      writer.WriteString(record.Winner);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseLevelData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static LevelData Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseLevelData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static LevelData Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseLevelData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static LevelData Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseLevelData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static LevelData Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseLevelData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static LevelData Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static LevelData DecodeFrom(ref BebopReader reader) {

      BaseTimeStepData[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BaseTimeStepData[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BaseTimeStepData x0;
          x0 = GameDataParser.TimeStepData.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      string field1;
      field1 = reader.ReadString();
      return new LevelData {
        TimeSteps = field0,
        Winner = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseLevelData, new() {
      BaseTimeStepData[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new BaseTimeStepData[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BaseTimeStepData x0;
          x0 = GameDataParser.TimeStepData.DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      string field1;
      field1 = reader.ReadString();
      return new T {
        TimeSteps = field0,
        Winner = field1,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Enum)]
  public enum MovingState : uint {
    Up = 0,
    Down = 1,
    Left = 2,
    Right = 3
  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BasePlayerState : System.IEquatable<BasePlayerState> {
    public const uint OpCode = 0x5;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public MovingState Direction { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Scores { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, long> Lives { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BasePosition[] ScorePositions { get; set; }

    public bool Equals(BasePlayerState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Direction == other.Direction && (Scores is null ? other.Scores is null : other.Scores is not null && Scores.SequenceEqual(other.Scores)) && (Lives is null ? other.Lives is null : other.Lives is not null && Lives.SequenceEqual(other.Lives)) && (PlayerPositions is null ? other.PlayerPositions is null : other.PlayerPositions is not null && PlayerPositions.SequenceEqual(other.PlayerPositions)) && (ScorePositions is null ? other.ScorePositions is null : other.ScorePositions is not null && ScorePositions.SequenceEqual(other.ScorePositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      hash ^= Direction.GetHashCode();
      hash ^= Scores.GetHashCode();
      hash ^= Lives.GetHashCode();
      hash ^= PlayerPositions.GetHashCode();
      hash ^= ScorePositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerState left, BasePlayerState right) => Equals(left, right);
    public static bool operator !=(BasePlayerState left, BasePlayerState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class PlayerState : BasePlayerState {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerState record, ref BebopWriter writer) {
      GameDataParser.SessionMsg.EncodeInto(record.Session, ref writer);
      writer.WriteEnum<MovingState>(record.Direction);
      writer.WriteUInt32(unchecked((uint)record.Scores.Count));
      foreach (var kv0 in record.Scores) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.Lives.Count));
      foreach (var kv0 in record.Lives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteInt64(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerPositions.Count));
      foreach (var kv0 in record.PlayerPositions) {
        writer.WriteGuid(kv0.Key);
        GameDataParser.Position.EncodeInto(kv0.Value, ref writer);
      }
      {
        var length0 = unchecked((uint)record.ScorePositions.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          GameDataParser.Position.EncodeInto(record.ScorePositions[i0], ref writer);
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerState DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = GameDataParser.SessionMsg.DecodeFrom(ref reader);
      MovingState field1;
      field1 = reader.ReadEnum<MovingState>();
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = GameDataParser.Position.DecodeFrom(ref reader);
          field4.Add(k0, v0);
        }
      }
      BasePosition[] field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = GameDataParser.Position.DecodeFrom(ref reader);
          field5[i0] = x0;
        }
      }
      return new PlayerState {
        Session = field0,
        Direction = field1,
        Scores = field2,
        Lives = field3,
        PlayerPositions = field4,
        ScorePositions = field5,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerState, new() {
      BaseSessionMsg field0;
      field0 = GameDataParser.SessionMsg.DecodeFrom(ref reader);
      MovingState field1;
      field1 = reader.ReadEnum<MovingState>();
      System.Collections.Generic.Dictionary<System.Guid, long> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, long> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, long>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          long v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadInt64();
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = GameDataParser.Position.DecodeFrom(ref reader);
          field4.Add(k0, v0);
        }
      }
      BasePosition[] field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = GameDataParser.Position.DecodeFrom(ref reader);
          field5[i0] = x0;
        }
      }
      return new T {
        Session = field0,
        Direction = field1,
        Scores = field2,
        Lives = field3,
        PlayerPositions = field4,
        ScorePositions = field5,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BasePosition : System.IEquatable<BasePosition> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public float X { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public float Y { get; set; }

    public bool Equals(BasePosition other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePosition baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= X.GetHashCode();
      hash ^= Y.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePosition left, BasePosition right) => Equals(left, right);
    public static bool operator !=(BasePosition left, BasePosition  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class Position : BasePosition {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePosition record, ref BebopWriter writer) {
      writer.WriteFloat32(record.X);
      writer.WriteFloat32(record.Y);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Position DecodeFrom(ref BebopReader reader) {

      float field0;
      field0 = reader.ReadFloat32();
      float field1;
      field1 = reader.ReadFloat32();
      return new Position {
        X = field0,
        Y = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePosition, new() {
      float field0;
      field0 = reader.ReadFloat32();
      float field1;
      field1 = reader.ReadFloat32();
      return new T {
        X = field0,
        Y = field1,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Message)]
  public abstract class BaseSessionMsg : System.IEquatable<BaseSessionMsg> {
    public const uint OpCode = 0x2;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? SessionId { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Guid? ClientId { get; set; }
    #nullable disable

    public bool Equals(BaseSessionMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return SessionId == other.SessionId && ClientId == other.ClientId;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSessionMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (SessionId is not null) hash ^= SessionId.GetHashCode();
      if (ClientId is not null) hash ^= ClientId.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSessionMsg left, BaseSessionMsg right) => Equals(left, right);
    public static bool operator !=(BaseSessionMsg left, BaseSessionMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Message)]
  public sealed class SessionMsg : BaseSessionMsg {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseSessionMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.SessionId is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.SessionId);
      }

      if (record.ClientId is not null) {
        writer.WriteByte(2);
        writer.WriteGuid(record.ClientId.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static SessionMsg DecodeFrom(ref BebopReader reader) {

      var record = new SessionMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseSessionMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadString();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Message)]
  public abstract class BaseTimeStepData : System.IEquatable<BaseTimeStepData> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public double? Timestamp { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BasePlayerState? PlayerState { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition>? GhostPositions { get; set; }
    #nullable disable

    public bool Equals(BaseTimeStepData other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Timestamp == other.Timestamp && PlayerState == other.PlayerState && (GhostPositions is null ? other.GhostPositions is null : other.GhostPositions is not null && GhostPositions.SequenceEqual(other.GhostPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseTimeStepData baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp is not null) hash ^= Timestamp.Value.GetHashCode();
      if (PlayerState is not null) hash ^= PlayerState.GetHashCode();
      if (GhostPositions is not null) hash ^= GhostPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseTimeStepData left, BaseTimeStepData right) => Equals(left, right);
    public static bool operator !=(BaseTimeStepData left, BaseTimeStepData  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.1.0")]
  [BebopRecord(BebopKind.Message)]
  public sealed class TimeStepData : BaseTimeStepData {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseTimeStepData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseTimeStepData record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseTimeStepData record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Timestamp is not null) {
        writer.WriteByte(1);
        writer.WriteFloat64(record.Timestamp.Value);
      }

      if (record.PlayerState is not null) {
        writer.WriteByte(2);
        GameDataParser.PlayerState.EncodeInto(record.PlayerState, ref writer);
      }

      if (record.GhostPositions is not null) {
        writer.WriteByte(3);
        writer.WriteUInt32(unchecked((uint)record.GhostPositions.Count));
        foreach (var kv0 in record.GhostPositions) {
          writer.WriteString(kv0.Key);
          GameDataParser.Position.EncodeInto(kv0.Value, ref writer);
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseTimeStepData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static TimeStepData Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseTimeStepData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static TimeStepData Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseTimeStepData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static TimeStepData Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseTimeStepData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static TimeStepData Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseTimeStepData, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static TimeStepData Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static TimeStepData DecodeFrom(ref BebopReader reader) {

      var record = new TimeStepData();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Timestamp = reader.ReadFloat64();
            break;
          case 2:
            record.PlayerState = GameDataParser.PlayerState.DecodeFrom(ref reader);
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.GhostPositions = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                string k0;
                BasePosition v0;
                k0 = reader.ReadString();
                v0 = GameDataParser.Position.DecodeFrom(ref reader);
                record.GhostPositions.Add(k0, v0);
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseTimeStepData, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Timestamp = reader.ReadFloat64();
            break;
          case 2:
            record.PlayerState = GameDataParser.PlayerState.DecodeFrom(ref reader);
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.GhostPositions = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
              for (var i0 = 0; i0 < length0; i0++) {
                string k0;
                BasePosition v0;
                k0 = reader.ReadString();
                v0 = GameDataParser.Position.DecodeFrom(ref reader);
                record.GhostPositions.Add(k0, v0);
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

  }

}
